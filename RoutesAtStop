
"""
this code is for the display of routes at a stop.
"""

#libs
import requests # needed for API functioning to work.
from datetime import datetime, UTC, timedelta # https://docs.python.org/3/library/datetime.html#datetime.datetime

# -4 hr to account for EST # converts to 12-hr clock

# CHANGELOG!
# moved date to its own variable
# Added API reader to keep the API off future code...
# so that it will just reference a txt file in the same folder named "API.txt"

try:
    with open("API.txt", "r") as file: API_KEY = file.read()
except FileNotFoundError:
    print("Error: API.txt file is missing!"); API_KEY = None

 # Read's API.txt to keep the API out of the code.

def output():
    # Alternate is to replace this with the geopy, and get the user input to return lat and lon.
    lat, lon = (41.69367820450357, -72.76272775194853) # vance building
        #41.53893285402787, -72.80120743546017) #debug - meriden station commuter parking
    # 41.7656200, -72.6727190 # Central Row
    return lat, lon

def get_routes_at_stop(lat, lon, max_distance=1500):
    lat, lon = output()
    url = "https://external.transitapp.com/v3/public/nearby_routes"
    headers = { "apiKey": API_KEY   } # API needs the key to be in the header. # only needs lat and lon to work.
    params = {  "lat": lat, "lon": lon,"max_distance": max_distance, "should_update_realtime": True  }
    response = requests.get(url, headers=headers, params=params)
    return response.json().get("routes", []) if response.status_code == 200 else [] # if 200, API works - else it didn't



def display_all_routes_at_stop(): # loops for days.
    latitude, longitude = output()
    routes = get_routes_at_stop(latitude, longitude, max_distance=1500)
    # Extract and print EVERY departure times and route short names
    for route in routes:
        route_short_name = route.get("route_short_name", "Unknown")
        if not route_short_name:
            continue
        for itinerary in route.get("itineraries", []):
            for schedule in itinerary.get("schedule_items", []):
                timestamp = schedule["departure_time"]
                est_time = datetime.fromtimestamp(timestamp, UTC) - timedelta(hours=4)
                formatted_time = est_time.strftime('%I:%M %p')  # 12-hour format with AM/PM
                formatted_date = est_time.strftime('%B %d')  # %B is the datetime variable for %m written out.
                print(f"{formatted_date} Route {route_short_name}, Departure Time - {formatted_time}")
                return formatted_date, formatted_time, route_short_name
display_all_routes_at_stop()

def display_some_routes_at_stop():  # loops for days.
    latitude, longitude = output() #filler for what e
    routes = get_routes_at_stop(latitude, longitude, max_distance=1500)
    print("For Stop - Meriden Union Station:") # hard code this to be the var.
    for route in routes:
        strRouteShortName = route.get("route_short_name") # , "Unknown")
        nextDeparture = None
        for itinerary in route.get("itineraries", []):
            for schedule in itinerary.get("schedule_items", []):
                timestamp = schedule["departure_time"]
                if nextDeparture is None or timestamp < nextDeparture: nextDeparture = timestamp
        if nextDeparture:  # Convert UTC to EST (-5 hours)
            est_time = datetime.fromtimestamp(nextDeparture, UTC) - timedelta(hours=4)
            formatted_time = est_time.strftime('%I:%M %p')  # 12-hour format with AM/PM
            formatted_date = est_time.strftime('%B %d')  # %B is the datetime variable for %m written out.
            print(f"{formatted_date} Route {strRouteShortName}, Next Departure Time - {formatted_time}")
            return formatted_date, formatted_time, strRouteShortName

# display_some_routes_at_stop()

"""
def handle_value(value):
    try:
        match value:
            case 1: display_all_routes_at_stop()
            case 2: display_some_routes_at_stop()
            case _: print("Invalid selection. Please choose either 1 or 2.")
    except Exception as e: print(f"An error occurred: {e}")
try:
    userinput = int(input("Select 1 for all routes, 2 for some routes: "))
    handle_value(userinput)
except ValueError:
    print("Invalid input! Please enter a number.")
"""
